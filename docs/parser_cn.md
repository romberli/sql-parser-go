# 语法解析

## 上下文无关文法(Context-Free Grammar)
上下文无关文法是一种形式文法, 是一个四元组G = (T, N, S, R), 其中
- T是终结符(Terminal)的有限集合, 无交集于N, 它们构成了句子的实际内容
- N是非终结符(Non-terminal)的有限集合, 它们表示在句子中不同类型的短语或子句
- S是开始符号, S ∈ N, 用来表示整个句子(或程序)
- R是产生式(Production Rule)的有限集合, 描述N到(T ⋃ N ⋃ ε)的关系, 使得X -> Y1Y2...Yi...Yn，X ∈ N, Yi ∈ (T ⋃ N ⋃ ε)成立

## 举例
SelectStatement -> selectKeyword ColumnList fromKeyword TableName WhereClause

ColumnList -> ColumnName | ColumnName commaOperator ColumnList

ColumnName -> identifier | identifier asKeyword identifier | identifier identifier

WhereClause -> whereKeyword Condition | ε

Condition -> ...


## 与正则文法的联系与区别
- 正则文法是上下文无关文法的子集
- 正则文法的产生式的右边部分最多只有一个非终结符，比如 X->aYb，其中a和b是终结符
- 对于常见的语法规则来讲正则文法是不够的, 比如正则文法无法表达成对出现的括号, 即{ (^i)^i | i >= 0 }

## 歧义性
如果一个文法针对相同的token流, 能产生多个不同的语法树, 则称该文法是有歧义的, 举例
- todo

## 自顶向下的解析方法(Top-Down)
1. 开始符号作为根节点
2. 针对产生式X -> Y1Y2...Yi...Yn, 将Y1Y2...Yi...Yn作为X的子节点
3. 如果子节点是非终结符, 递归地对该子节点重复第2步操作, 直到所有的非终结符都被替换为终结符
4. 代表算法: 递归下降算法, LL(k)算法
5. 代表产品: Java编译器

注: 只有终结符才能成为叶子节点

## 自底向上的解析方法(Bottom-Up)
1. 从叶子节点开始, 逐步向上构建语法树
2. 选择某个产生式, 使用产生式的左部作为其父节点
3. 重复上述步骤直至替换为开始符号
4. 代表算法: LR(k)算法
5. 代表产品: MySQL SQL解析器

由于自顶向下的解析方法更加符合直觉, 便于理解, 因此本项目使用了自顶向下的解析方法, 分别通过递归下降和LL(1)两种算法实现了语法解析器

## 递归下降算法
### 算法描述
递归下降算法是自上而下的语法解析的一种实现方式
- 将开始符号作为初始状态
- 对于一个非终结符, 要从左到右依次匹配其产生式中的每个项(最左推导)
- 在匹配产生式右边的非终结符时，要下降一层，继续匹配该非终结符的产生式
- 如果一个语法规则有多个可选的产生式, 那么只要有一个产生式匹配成功就行
- 如果一个产生式匹配不成功，那就回退回来, 尝试另一个产生式, 这种回退过程, 叫做回溯(Backtracking)

### 缺点
- 存在左递归问题
- 递归下降算法的回溯过程是非常耗时的, 当匹配失败时, 因为它要不断地回溯到上一个状态, 重新匹配产生式

### 左递归问题
- 假设有产生式A -> Aa | b, 那么在递归下降算法中, 会出现无限递归的情况, 因为A -> Aa会一直匹配下去, 无法匹配到b
- 解决方法: 将产生式A -> Aa | b转换为A -> bA' | b, A' -> aA' | ε

