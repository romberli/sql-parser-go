# 语法解析

## 上下文无关文法(Context-Free Grammar)
上下文无关文法是一种形式文法, 是一个四元组G = (T, N, S, R), 其中
- T是终结符(Terminal)的有限集合, 无交集于N, 它们构成了句子的实际内容
- N是非终结符(Non-terminal)的有限集合, 它们表示在句子中不同类型的短语或子句
- S是开始符号, S ∈ N, 用来表示整个句子(或程序)
- R是产生式(Production Rule)的有限集合, 描述N到(T ⋃ N ⋃ ε)的关系, 使得X -> Y1Y2...Yi...Yn，X ∈ N, Yi ∈ (T ⋃ N ⋃ ε)成立

## 举例
SelectStatement -> selectKeyword ColumnList fromKeyword TableName WhereClause

ColumnList -> ColumnName | ColumnName commaOperator ColumnList

ColumnName -> identifier | identifier asKeyword identifier | identifier identifier

WhereClause -> whereKeyword Condition | ε

Condition -> ...


## 与正则文法的联系与区别
- 正则文法是上下文无关文法的子集
- 正则文法的产生式的右边部分最多只有一个非终结符，比如 X->aYb，其中a和b是终结符
- 对于常见的语法规则来讲正则文法是不够的, 比如正则文法无法表达成对出现的括号, 即{ (^i)^i | i >= 0 }

## 歧义性
如果一个文法针对相同的token流, 能产生多个不同的语法树, 则称该文法是有歧义的, 举例
- todo

## 自顶向下的解析方法(Top-Down)
1. 开始符号作为根节点
2. 针对产生式X -> Y1Y2...Yi...Yn, 将Y1Y2...Yi...Yn作为X的子节点
3. 如果子节点是非终结符, 递归地对该子节点重复第2步操作, 直到所有的非终结符都被替换为终结符
4. 代表算法: 递归下降算法, LL(k)算法
5. 代表产品: Java编译器

注: 只有终结符才能成为叶子节点

## 自底向上的解析方法(Bottom-Up)
1. 从叶子节点开始, 逐步向上构建语法树
2. 选择某个产生式, 使用产生式的左部作为其父节点
3. 重复上述步骤直至替换为开始符号
4. 代表算法: LR(k)算法
5. 代表产品: MySQL SQL解析器

自顶向下的解析方法更加符合直觉, 便于理解, 本项目使用了自顶向下的解析方法, 分别通过递归下降和LL(1)两种算法实现了语法解析器

## 递归下降算法
### 算法描述
递归下降算法是自上而下的语法解析的一种实现方式
- 将开始符号作为初始状态
- 对于一个非终结符, 要从左到右依次匹配其产生式中的每个项(最左推导)
- 在匹配产生式右边的非终结符时，要下降一层，继续匹配该非终结符的产生式
- 如果一个语法规则有多个可选的产生式, 那么只要有一个产生式匹配成功就行
- 如果一个产生式匹配不成功，那就回退回来, 尝试另一个产生式, 这种回退过程, 叫做回溯(Backtracking)

### 缺点
- 存在左递归问题
- 递归下降算法的回溯过程是非常耗时的, 当匹配失败时, 因为它要不断地回溯到上一个状态, 重新匹配产生式

### 左递归问题
- 假设有产生式X -> Xa | b, 那么在递归下降算法中, 会出现无限递归的情况, 因为X -> Xa会一直匹配下去, 无法匹配到b
- 解决方法: 将产生式X -> Xa | b转换为X -> bX' | b, X' -> aX' | ε

## LL(1)算法
### First集合
- 定义: First(X) = { t | X →* tA} ∪ {ε | X →* ε}
- 算法描述:
    - 如果t是终结符, 则First(X) = {t}
    - 如果满足以下2个条件之一, ε ∈ First(X)
        - 当X → ε
        - 针对X -> A1A2...Ai...An, 如果所有的i (1<=i<=n), ε ∈ First(Ai)
    - 如果满足以下2个条件之一, First(B) ⊆ First(X)
        - 如果X -> B
        - 针对X -> A1A2...Ai...AnB, 如果所有的i (1<=i<=n), ε ∈ First(Ai)
- 通俗版本:
    - 如果X以终结符t开头, 则First(X)包含t
    - 如果X以非终结符A开头, 则First(X)包含First(A)
    - 如果X的第一个非终结符A能够产生ε, 则需要看下一个元素B, 把First(B)加入到First(X)中, 以此类推
    - 如果所有元素都可能产生ε, 则First(X)包含ε
    - 如果X有多个产生式, 则First(X)应包含所有产生式的First集合

### Follow集合
- 定义: Follow(X) = { t | S →* AXtB}
- 算法描述:
  - 如果X是开始符号, 则$ ∈ Follow(X)
  - 针对产生式X -> AB
    - First(B) ⊆ Follow(A)且Follow(X) ⊆ Follow(B)
    - 如果B ->* ε, 则Follow(X) ⊆ Follow(A)
- 通俗版本: X -> At | ABC
  - 如果A后面跟着的是终结符t，则Follow(A)包含t
  - 如果后面是非终结符B，则Follow(A)包含First(B)
  - 如果后面的非终结符B可能产生ε，就需要查看下一个元素C, 把First(C)加入到Follow(A)中, 以此类推, 直到找到$

### 算法描述
- 在推导的时候, 如果有多个候选产生式可供选择时, 通过预读后续的token来选择使用哪种产生式, 从而避免回溯, 如果只预读一个token, 则称为LL(1)算法
- LL(1)算法的效率较高, 因为它只需要预读一个token, 而不需要像递归下降算法那样回溯到上一个状态, 重新匹配产生式
- LL(1)算法的缺点是, 语法规则必须满足LL(1)文法, 即针对产生式X -> A | B, 需要同时满足以下条件:
  - 如果A, B均不能推导出ε，则 First(A) ∩ First(B) = ∅, 即A, B不能有公共的前导终结符
  - A 和 B 至多有一个能推导出 ε
  - 如果 B *═> ε，则 First(A) ∩ Follow(X) = ∅

### 算法实现
- 第一种采用递归下降算法, 只要语言符合LL(1)文法, 即可准确预测出应该采用哪个产生式, 因此不会产生回溯
- 第二种可构造一个驱动表, 通过First和Follow集合构造一张预测分析表, 根据这个表, 查找在遇到什么Token的情况下, 应该走哪条路径
- 通过提取左公因子, 避免First集合产生交集
